<h2>Linear time(선형 시간)</h2>

다음 예시 코드를 고려해보세요:<br>
```swift
func printNames(names: [String]) {
    for name in names {
        print(name)
    }
}
```

이 함수는 문자열 배열에 있는 모든 이름을 출력합니다.<br>
입력 배열의 크기가 증가함에 따라, for 루프가 수행하는 반복 횟수도 같은 양만큼 증가합니다.<br>

이러한 동작은 선형 시간 복잡도라고 알려져 있습니다:

<img src="https://github.com/devKobe24/images/blob/main/2024-01-10-linear-time.png?raw=true"><br>

선형 시간 복잡도는 일반적으로 이해하기 가장 쉽습니다.<br>
데이터의 양이 증가함에 따라, 실행 시간도 같은 양만큼 증가합니다.<br>
이것이 바로 위에서 보여진 직선형 그래프의 이유입니다.<br>
선형 시간의 빅-오 표기법은 O(n)입니다.<br>

> 데이터 전체를 두 번 순회하는 루프와 O(1) 메소드를 여섯 번 호출하는 함수는 O(2n + 6)일까요?
>
> 시간 복잡도는 성능의 고차원적 형태만을 제공하므로, 정해진 횟수만큼 반복되는 루프는 계산에 포함되지 않습니다.
> 최종 빅 오 표기법에서는 모든 상수가 생략됩니다.
> 다시 말해, O(2n + 6)은 놀랍게도 O(n)과 동일합니다.
> 
> 이 포스트의 주된 관심사는 아니지만, 절대적인 효율성을 위한 최적화는 중요할 수 있습니다.
> 회사들은 빅 오 표기법을 무시하는 상수의 기울기를 줄이기 위해 수십억원의 연구 개발비를 투자합니다.
> 예를 들어, GPU 최적화된 알고리즘 버전은 순진한 CPU 버전보다 100배 빠를 수 있으면서도 O(n)을 유지할 수 있습니다.
> 이러한 종류의 최적화는 무시할 예정이지만, 이와 같은 속도 향상은 중요합니다.
