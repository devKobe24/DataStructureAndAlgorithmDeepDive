<h2>Logarithmic time(로그 시간)</h2>

<p>지금까지, 입력의 각 요소가 최소 한 번은 검사되는 선형 및 이차 시간 복잡도에 대해 배웠습니다.<br>
    그러나 입력의 일부만 검사되면 되는 시나리오도 있으며, 이는 더 빠른 실행 시간으로 이어집니다.</p><br>

<p>이 범주의 시간 복잡도에 속하는 알고리즘은 입력 데이터에 대한 일부 가정을 통해 몇 가지 단축 경로를 활용할 수 있는 것들입니다.<br>
    예를 들어, <strong>정렬된</strong> 정수 배열이 있다면, 특정 값이 존재하는지 가장 빠르게 찾는 방법은 무엇일까요?</p><br>

<p>단순한 해결책은 배열의 시작부터 끝까지 모든 요소를 검사하여 결론에 도달하는 것입니다.<br>
    각 요소를 한 번씩 검사하기 때문에, 이는 O(n) 알고리즘이 됩니다.<br>
    선형 시간은 꽤 좋은 성능이지만, 더 나은 방법이 있습니다.<br>
    입력 배열이 정렬되어 있다면, 최적화를 할 수 있습니다.<br>
    다음 코드를 고려해보세요:</p>
    
```swift
let numbers = [1, 3, 56, 66, 68, 80, 99, 105, 450]

func naiveContains(_ value: Int, in array: [Int]) -> Bool {
    for element in array {
        if element == value {
            return true
        }
    }
    
    return false
}
```

<p>
    만약 배열에서 숫자 451이 있는지 확인한다고 할 때, 단순한 알고리즘은 시작부터 끝까지 반복하여<br>
    배열의 아홈 값에 대해 총 아홉 번 검사를 해야 합니다.<br>
    그러나 배열이 정렬되어 있다면, 중간값을 확인함으로써 필요한 비교의 절반을 바로 줄일 수 있습니다.<br>
</p>

```swift
func naiveContain(_ value: Int, in array: [Int]) -> Bool {
    guard !array.isEmpty else { return false }
    let middleIndex = array.count / 2
    
    if value <= array[middleIndex] {
        for index in 0...middleIndex {
            if array[index] == value {
                return true
            }
        }
    } else {
        for index in middleIndex..<array.count {
            if array[index] == value {
                return true
            }
        }
    }
    
    return false
}
```

<p>
    위의 함수는 배열의 절반만 확인하여 결론을 내리는 작지만 의미 있는 최적화를 수행합니다.<br>
    <br>
    이 알고리즘은 먼저 중간값을 확인하여 원하는 값과 비교합니다.<br>
    만약 중간값이 원하는 값보다 크다면, 알고리즘은 배열의 오른쪽 절반의 값을 볼 필요가 없습니다.<br>
    배열이 정렬되어 있기 때문에, 중간값의 오른 쪽에 있는 값들은 더 커질 수밖에 없습니다.<br>
    <br>
    반대의 경우, 중간값이 원하는 값보다 작다면, 알고리즘은 배열의 왼쪽을 볼 필요가 없습니다.<br>
    이는 비교 횟수를 절반으로 줄이는 작지만 의미 있는 최적화입니다.<br>
</p>

<p>
    이 최적화를 이 메서드 전체에서 반복적으로 적용할 수 있다면 어떨까요?<br>
    '이진 탐색'에 대해서는 추후에 알아보게 될 것입니다.<br>
    <br>
    필요한 비교의 절반을 반복적으로 제거할 수 있는 알고리즘은 로그 시간 복잡도를 가집니다.<br>
    입력 데이터가 증가함에 따라 로그 시간 알고리즘이 어떻게 동작하는지 보여주는 그래프는 다음과 같습니다:<br>
    <br>
    <img src="https://github.com/devKobe24/images/blob/main/2024-01-10-Logarithmic-time.png?raw=true"><br>
    <br>
    입력 데이터가 증가해도, 알고리즘을 실행하는 데 걸리는 시간은 느린 비율로 증가합니다.<br>
    자세히 보면, 그래프가 점근적 행동을 보이는 것처럼 보일 수 있습니다.<br>
    이는 필요한 비교 횟수를 반으로 줄이는 것의 영향을 고려하면 설명될 수 있습니다.<br>
</p>

<p>
    입력 크기가 100일 때, 비교 횟수를 반으로 줄이면 50번의 비교를 절약할 수 있습니다.<br>
    만약 입력 크기가 100,000이라면, 비교 횟수를 반으로 줄이는 것은 50,000번의 비교를 절약하는 것을 의미합니다.<br>
    데이터가 많을수록 반으로 줄이는 효과는 더 커집니다.<br>
    따라서, 그래프가 수평에 가까워지는 것 처럼 보일 수 있습니다.<br>
    <br>
    이 범주에 속하는 알고리즘은 소수이지만, 그것을 허용하는 상황에서는 매우 강력합니다.<br>
    로그 시간 복잡도를 나타내는 빅 오 표기법은 O(log n)입니다.
</p>

> 로그의 밑은 2인가요, 10인가요, 아니면 자연 로그인가요?
> 
> 위의 예시에서는 로그 밑이 2에 해당합니다.
> 하지만 빅 오 표기법은 성능의 형태에만 관심을 가지기 때문에, 실제 로그의 밑은 중요하지 않습니다.
